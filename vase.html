<html>
<body>
<script src="js/three.min.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/MTLLoader.js"></script>
<script src="js/KeyboardState.js"></script>
<style>
#canvas canvas {
    border: 3px solid blue;
} 
</style>

<div id="canvas" style="position: absolute;  margin: auto; top: 5vh;
  right: 0;  bottom: 0;  left: 0;
  text-align:center; vertical-align: middle">
  
</div>

<script>
var scene, camera, renderer;
var geometry, material, mesh;
var objs = [];
var turnSpeed = 0.02;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();


var toggleBones = 0;
var mixer, facesClip, bonesClip;


init();
animate();

function init() {



    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
    camera.position.z = 300;

    // scene

    scene = new THREE.Scene();

    // var ambient = new THREE.AmbientLight( 0x101030 );
    // scene.add( ambient );
    var ambient = new THREE.AmbientLight( 0x444444 );
    scene.add( ambient );

    // var directionalLight = new THREE.DirectionalLight( 0xffeedd );
    // directionalLight.position.set( 0, 0, 1 );
    // scene.add( directionalLight );


    var directionalLight = new THREE.DirectionalLight( 0xffeedd );
    directionalLight.position.set( 0, 0, 1 ).normalize();
    scene.add( directionalLight );

    // geometry = new THREE.BoxGeometry( 40, 10, 10 );
    // colorMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
    // wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x00ee00, wireframe: true, transparent: true } ); 
    // material = [ colorMaterial, wireframeMaterial ]; 
    
    // //mesh = new THREE.Mesh( geometry, material );
    // mesh = THREE.SceneUtils.createMultiMaterialObject( 
    //     geometry, material );
    // scene.add( mesh );


    // outlineMaterial2 = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.BackSide } );
    // outlineMesh2 = new THREE.Mesh( geometry, outlineMaterial2 );
    // outlineMesh2.position = mesh.position;
    // outlineMesh2.scale.multiplyScalar(1.1);
    // scene.add( outlineMesh2 );
    var onProgress = function ( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    };

    var onError = function ( xhr ) {
    };

    var texture = new THREE.Texture();
    var loader = new THREE.ImageLoader(  );
    loader.load( 'textures/UV_Grid_Sm.jpg', function ( image ) {

        texture.image = image;
        texture.needsUpdate = true;

    } );

    var mtlLoader = new THREE.MTLLoader();
    mtlLoader.setPath( 'obj/' );
    mtlLoader.load( 'male02.mtl', function( materials ) {
        materials.preload();
        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials( materials );
        objLoader.setPath( 'obj/' );
        objLoader.load( 'male02.obj', function ( object ) {
            objs[0] = object;
            object.position.y = - 95;
            scene.add( object );
        }, onProgress, onError );
    });


    // var loader = new THREE.OBJLoader(  );
    // loader.load( 'obj/male02.obj', function ( object ) {

    //     objs[0] = object;

    //     object.traverse( function ( child ) {

    //         if ( child instanceof THREE.Mesh ) {

    //             child.material.map = texture;

    //         }

    //     } );

    //     object.position.y = -90;
    //     scene.add( object );


    // }, onProgress, onError );




    var jsonLoader = new THREE.JSONLoader();
    jsonLoader.load( "obj/knight.js", function ( geometry, materials ) {


                geometry.computeBoundingBox();
                var bb = geometry.boundingBox;
                var s = 15;


                mesh = new THREE.SkinnedMesh( geometry, new THREE.MultiMaterial( materials ) );
                mesh.name = "Knight Mesh";
                mesh.position.set( 0, -90 -bb.min.y * s, -10 );
                mesh.scale.set( s, s, s );
                scene.add( mesh );

                mesh.castShadow = true;
                mesh.receiveShadow = true;


                helper = new THREE.SkeletonHelper( mesh );
                helper.material.linewidth = 3;
                helper.visible = false;
                scene.add( helper );

                mixer = new THREE.AnimationMixer( mesh );
                //mixer.play();

                bonesClip = geometry.animations[0];
                facesClip = THREE.AnimationClip.CreateFromMorphTargetSequence( 'facialExpressions', mesh.geometry.morphTargets, 3 );

                mixer.clipAction( facesClip, mesh ).play();

        objs[1] = mesh;
        objs[2] = helper;

        //geometry.position.y = -180;
        //scene.add( geometry );
    });
                
    

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth*0.9, window.innerHeight*0.9 );

    container = document.getElementById( 'canvas' );
    container.appendChild( renderer.domElement );

}

function animate() {

    requestAnimationFrame( animate );
    render();       
    update();

}

function update()
{
    // delta = change in time since last call (seconds)
    delta = clock.getDelta(); 
    var moveDistance = 100 * delta;

    if(objs[0] && objs[1]){

        // move forwards / backwards
        if ( keyboard.pressed("down") )
            objs[0].translateZ( -moveDistance );
        if ( keyboard.pressed("up") )
            objs[0].translateZ(  moveDistance );
            
        // rotate left/right
        if ( keyboard.pressed("left") )

            objs[0].rotation.y += turnSpeed;
        if ( keyboard.pressed("right") )
            objs[0].rotation.y -= turnSpeed;

        if ( keyboard.pressed("s") )
            objs[1].translateZ( -moveDistance );
        if ( keyboard.pressed("w") )
            objs[1].translateZ(  moveDistance );
        // rotate left/right
        if ( keyboard.pressed("a") )
            objs[1].rotation.y += turnSpeed;
        if ( keyboard.pressed("d") )
            objs[1].rotation.y -= turnSpeed;

        if ( keyboard.pressed("b") )   // b for bones
            var currentTime = window.performance && window.performance.now ? window.performance.now() : new Date().getTime();
            if (currentTime - toggleBones  > 300){
                objs[2].visible = !objs[2].visible;
                toggleBones = currentTime;
            }
    }           
    
    var walkingKeys = ["up", "down", "left", "right"];
    for (var i = 0; i < walkingKeys.length; i++)
    {
        if ( keyboard.pressed(walkingKeys[i]) )
            walking = true;
    }
    if( mixer ) {
        mixer.update( delta );
        helper.update();
    }
}

function render() 
{
    renderer.render( scene, camera );

}

</script>
</body>
</html>
